These are my notes based off of redblobgames.com's incredibly quality post [Making maps with noise functions](https://www.redblobgames.com/maps/terrain-from-noise/), which details an algorithm for procedurally generating a biome/terrain map (think vegation, elevation, humidity). As the title suggests, the primary tool used is that staple of procgen, noise functions, and the post serves as a great introduction to some basic theory and techniques in that area. The final result from the source material looks like this:

[source_tutorial_final_example_image](source)

My main motivation for learning these techniques is to apply them in creating level maps for a roguelike game. While the source material uses psuedocode, my post will provide working JavaScript the reader can run to reproduce the relevant examples. Furthermore, my final goal for this post will be to generate a roguelike map using these techhniques.

## Finding a webpack-compatible JavaScript noise function library

Before I can try any of the examples in the tutorial, I need a JavaScript noise library that works with webpack so I can use it within create-react-app. The one that I want to use, [noisejs](https://github.com/josephg/noisejs), hasn't been updated in 6 years, and uses an older, single-file module format that isn't compatible with webpack. To work around this, I just copied the `perlin.js` file directly into the `src` folder of my create-react-app, and made a few small edits so that all the methods of the library are bound to a global (for that file) `Noise` variable. Finally, I added an `export default Noise` statement at the end of the file. Now, I can `import Noise from './perlin';` to use it in my React app. 

The 2D demo example for `noisejs`'s github repo uses a perlin function to color a painting on the HTML canvas. It looks like this:

[noisejs_demo_image](source)

When you run this example, every time you refresh the page, you'll get a different painting, and the "rendered in ... ms" time will likely vary.

Here is my `index.js` that reproduces the `noisejs` repo demo in create-react-app, with some comments to explain what's happening:
```js
import React, {useEffect} from 'react';
import ReactDOM from 'react-dom';
import Noise from './perlin';
import './index.css';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

function App() {
  useEffect(() => {
    const canvas = document.querySelector('canvas');
    canvas.width = 600;
    canvas.height = 200;
    const ctx = canvas.getContext('2d');
 
    const image = ctx.createImageData(canvas.width, canvas.height);
    const data = image.data;

    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createImageData
    // `createImageData` returns a rectangular, 2D `ImageData` object whose properties are 
    // width, height, and data. The `data` prop is an array containing the rgba color data for every pixel 
    // in the image. This makes `ImageData` objects useful for programmatically creating 2D images, just
    // like we'll be doing with these noise functions.

    const start = Date.now();

    Noise.seed(Math.random());
    
    for (let x = 0; x < canvas.width; x++) {
      for (let y = 0; y < canvas.height; y++) {
        // In the tests I ran, the `value` returned by perlin2 was a "random" float that was always between 
        // 0.00 and 0.19, usually falling under 0.10. However, I suspect that the actual range of 
        // values generated by perlin2 is between 0.00 and 1.00, and my results were limited by the section
        // I was testing. 
        let value = Math.abs(Noise.perlin2(x / 100, y / 100));
        value *= 256; // scale 'value' to RGB 

        const cell = (x + y * canvas.width) * 4;
        // Red, Green, and Blue intially all get the same value. This results in varying shades of grey 
        // painted on to the canvas
        data[cell] = data[cell + 1] = data[cell + 2] = value;
        // Then we choose 1 color, Red in this case, receiving a multiplier. This results in bands of red
        // being painted over the greys.
        data[cell] += Math.max(0, (25 - value) * 8);
        // Set opacity to 1 for every pixel.
        data[cell + 3] = 255; // alpha.
      }
    }
    
    const end = Date.now();
    ctx.putImageData(image, 0, 0);    
    ctx.font = '16px sans-serif'
    ctx.textAlign = 'center';
    ctx.fillText('Rendered in ' + (end - start) + ' ms', canvas.width / 2, canvas.height - 20);
  }, []);

  return (
    <div className="App">
      <div className='centerbox'><canvas></canvas></div>
    </div>
  );
}
```

## REFERENCES
* http://asserttrue.blogspot.com/2011/12/perlin-noise-in-javascript_31.html